getwd()
load("replicas_Identify_Dist_RelativeBias_Forecasting_1000_2reg_ForStudent.rds")
any(sapply(repl_estimation, is.null)) ##Verify null entries#
any(sapply(repl, is.null)) ##Verify null entries#
any(sapply(repl_compare_dist_todo, is.null)) ##Verify null entries#
n_rep=1000 ###Set number of simulations#
fun = function(x){x/n_rep}#
regimes=2#
veces_est<-vector("list",regimes)#
longitud_est<-vector("list",regimes)#
sd_est<-vector("list",regimes)#
h.ahead=10#
k = 3 ##Dimension of the output vector#
v=2 ## Dimension of the exogenous variable vector#
ars <- list(p=c(1,2),q=c(1,0),d=c(1,0))#
###Create vectors for get counts#
veces<-vector("list",h.ahead)#
longitud<-vector("list",h.ahead)#
sd<-vector("list",h.ahead)#
###Counts for estimation ----#
for(reg in 1:regimes){#
  dime_inter<-dim(Rg[[reg]]$cs)#
  dime_phi=list()#
  for(orders in 1:ars$p[reg]){#
       dime_phi<-append(dime_phi,list(dim(Rg[[reg]]$Location$phi1)))#
     }#
  dime_sigma<-dim(Rg[[reg]]$Sigma)#
  suma_intercept<-matrix(rep(0,prod(dime_inter)),dime_inter[1],dime_inter[2])#
  suma_phi=list()#
  for(orders in 1:ars$p[reg]){#
    suma_phi<-append(suma_phi,list(matrix(rep(0,prod(dime_phi[[orders]])),dime_phi[[orders]][1],dime_phi[[orders]][2])))#
  }#
  if(reg==1)#
  {#
    dime_beta=list()#
    for(orders in 1:ars$q[reg]){#
      dime_beta<-append(dime_beta,list(dim(Rg[[reg]]$Location$beta1)))}#
    dime_delta=list()#
    for(orders in 1:ars$d[reg]){#
      dime_delta<-append(dime_delta,list(dim(Rg[[reg]]$Location$delta1)))}#
    suma_beta=list()#
    for(orders in 1:ars$p[reg]){#
      suma_beta<-append(suma_beta,list(matrix(rep(0,prod(dime_beta[[orders]])),dime_beta[[orders]][1],dime_beta[[orders]][2])))}#
      suma_delta=list()#
      for(orders in 1:ars$d[reg]){#
        suma_delta<-append(suma_delta,list(matrix(rep(0,prod(dime_delta[[orders]])),dime_delta[[orders]][1],dime_delta[[orders]][2])))}#
  } #
  suma_sigma<-matrix(rep(0,prod(dime_sigma)),dime_sigma[1],dime_sigma[2])#
  for(rep in 1:n_rep){#
    ###Autoregressive#
    row.names.obj_Reg_autoreg<-rownames(repl_estimation[[rep]]$non_structural[[reg]]$Autoregressive)#
    col.names.obj_Reg_autoreg<-colnames(repl_estimation[[rep]]$non_structural[[reg]]$Autoregressive)#
    pos.mean<-which(colnames(repl_estimation[[rep]]$non_structural[[reg]]$Autoregressive)==col.names.obj_Reg_autoreg[1])#
    pos.low<-which(colnames(repl_estimation[[rep]]$non_structural[[reg]]$Autoregressive)==col.names.obj_Reg_autoreg[4])#
    pos.high<-which(colnames(repl_estimation[[rep]]$non_structural[[reg]]$Autoregressive)==col.names.obj_Reg_autoreg[5])#
    pos.sd<-which(colnames(repl_estimation[[rep]]$non_structural[[reg]]$Autoregressive)==col.names.obj_Reg_autoreg[2])#
    ####IC#
    ###low#
    int.low_Reg<-repl_estimation[[rep]]$non_structural[[reg]]$Autoregressive[,pos.low]#
    int.low.intercep_Reg<-int.low_Reg[row.names.obj_Reg_autoreg[1],]#
    int.low_Phi_Reg<-t(int.low_Reg[row.names.obj_Reg_autoreg[2:(k+1)],])#
    if(ars$q[reg]!=0){#
    int.low_Beta_Reg<-t(int.low_Reg[row.names.obj_Reg_autoreg[(k+2):(k+1+v)],])#
    }#
    if(ars$d[reg]!=0){#
      int.low_Delta_Reg<-t(int.low_Reg[row.names.obj_Reg_autoreg[(k+1+v+1):(k+1+v+1)],])#
    }#
    ###high#
    int.high_Reg<-repl_estimation[[rep]]$non_structural[[reg]]$Autoregressive[,pos.high]#
    int.high.intercep_Reg<-int.high_Reg[row.names.obj_Reg_autoreg[1],]#
    int.high_Phi_Reg<-t(int.high_Reg[row.names.obj_Reg_autoreg[2:(k+1)],])#
    if(ars$p[reg]>1){#
      int.low_Phi2_Reg<-t(int.low_Reg[row.names.obj_Reg_autoreg[(k+2):(2*k+1)],])#
      int.high_Phi2_Reg<-t(int.high_Reg[row.names.obj_Reg_autoreg[(k+2):(2*k+1)],])#
    }#
    if(ars$q[reg]!=0){#
    int.high_Beta_Reg<-t(int.high_Reg[row.names.obj_Reg_autoreg[(k+2):(k+1+v)],])#
    }#
    if(ars$d[reg]!=0){#
      int.high_Delta_Reg<-t(int.high_Reg[row.names.obj_Reg_autoreg[(k+1+v+1):(k+1+v+1)],])#
    }#
    ####Phi#
    Phi_TF<-(int.low_Phi_Reg<Rg[[reg]]$Location$phi1) & (Rg[[reg]]$Location$phi1<int.high_Phi_Reg)#
    Include_Phi<- matrix(as.integer(as.logical(Phi_TF)),dime_phi[[reg]][1],dime_phi[[reg]][2])#
    suma_phi[[1]]<-suma_phi[[1]]+Include_Phi#
    if(reg==2){#
      Phi2_TF<-(int.low_Phi2_Reg<Rg[[reg]]$Location$phi2) & (Rg[[reg]]$Location$phi2<int.high_Phi2_Reg)#
      Include_Phi2<- matrix(as.integer(as.logical(Phi2_TF)),dime_phi[[reg]][1],dime_phi[[reg]][2])#
      suma_phi[[2]]<-suma_phi[[2]]+Include_Phi2  #
    }#
    ####Comparación#
    Intercept_TF<-(int.low.intercep_Reg<Rg[[reg]]$cs) & (Rg[[reg]]$cs<int.high.intercep_Reg)#
    Include_Intercept<- matrix(as.integer(as.logical(Intercept_TF)),dime_inter[1],dime_inter[2])#
    suma_intercept<-suma_intercept+Include_Intercept#
    ####Beta#
    if(ars$q[reg]!=0){#
    Beta_TF<-(int.low_Beta_Reg<Rg[[reg]]$Location$beta1) & (Rg[[reg]]$Location$beta1<int.high_Beta_Reg)#
    Include_Beta<- matrix(as.integer(as.logical(Beta_TF)),dime_beta[[reg]][1],dime_beta[[reg]][2])#
    suma_beta[[reg]]<-suma_beta[[reg]]+Include_Beta#
    }#
    ####Delta#
    if(ars$d[reg]!=0){#
      Delta_TF<-(int.low_Delta_Reg<t(Rg[[reg]]$Location$delta1)) & (t(Rg[[reg]]$Location$delta1)<int.high_Delta_Reg)#
      Include_Delta<- matrix(as.integer(as.logical(Delta_TF)),dime_delta[[reg]][1],dime_delta[[reg]][2])#
      suma_delta[[reg]]<-suma_delta[[reg]]+Include_Delta#
    }#
    ###Sigma#
    row.names.obj_Reg_scale<-rownames(repl_estimation[[rep]]$non_structural[[reg]]$Scale)#
    col.names.obj_Reg_scale<-colnames(repl_estimation[[rep]]$non_structural[[reg]]$Scale)#
    pos.mean_scale<-which(colnames(repl_estimation[[rep]]$non_structural[[reg]]$Scale)==col.names.obj_Reg_scale[1])#
    pos.low_scale<-which(colnames(repl_estimation[[rep]]$non_structural[[reg]]$Scale)==col.names.obj_Reg_scale[2])#
    pos.high_scale<-which(colnames(repl_estimation[[rep]]$non_structural[[reg]]$Scale)==col.names.obj_Reg_scale[3])#
    ####IC#
    ###low#
    int.low_Reg_scale<-repl_estimation[[rep]]$non_structural[[reg]]$Scale[,pos.low_scale]#
    int.low_Sigma_Reg<-t(int.low_Reg_scale)#
    ###high#
    int.high_Reg_scale<-repl_estimation[[rep]]$non_structural[[reg]]$Scale[,pos.high_scale]#
    int.high_Sigma_Reg<-t(int.high_Reg_scale)#
    ####Comparación#
    Sigma_TF<-(int.low_Sigma_Reg<(Rg[[reg]]$Sigma)) & ((Rg[[reg]]$Sigma)<int.high_Sigma_Reg)#
    Include_Sigma<- matrix(as.integer(as.logical(Sigma_TF)),dime_sigma[1],dime_sigma[2])#
    suma_sigma<-suma_sigma+Include_Sigma#
    print(rep)#
  }#
  if(reg==1){#
  veces_est[[reg]]<-list(Intercept=suma_intercept,Phi=suma_phi[[1]],Beta=suma_beta[[1]],Delta=suma_delta[[1]],Sigma=suma_sigma)#
  }#
  if(reg==2)#
  {veces_est[[reg]]<-list(Intercept=suma_intercept,Phi=suma_phi[[1]],Phi2=suma_phi[[2]],Sigma=suma_sigma)}#
}#
#
#para.extra=FALSE#
para.extra=TRUE#
if(isTRUE(para.extra)){#
#
extra_1<-extra#
suma_extra<-rep(0,length(extra_1))#
names.extra<-colnames(repl_estimation[[1]]$extra)#
pos.low.extra<-which(colnames(repl_estimation[[1]]$extra)==names.extra[4])#
pos.high.extra<-which(colnames(repl_estimation[[1]]$extra)==names.extra[5])#
sesgo_extra<-rep(0,length(extra_1))#
}
suma_thresholds<-matrix(rep(0,regimes-1),regimes-1,1)#
dife_thresholds<-matrix(rep(0,regimes-1),regimes-1,1)#
r_true<-as.matrix(umbrales)#
delay<-rep(0,n_rep)#
#
for(rep in 1:n_rep){#
  dife_thresholds=dife_thresholds+(repl_estimation[[rep]]$thresholds[,1]-r_true)#
  delay[rep]<-repl_estimation[[rep]]$d#
  if(isTRUE(para.extra)){#
    for(l in 1:length(extra_1)){#
  	sesgo_extra=sesgo_extra+(repl_estimation[[rep]]$extra[,l]-extra_1)#
  if((repl_estimation[[rep]]$extra[l,pos.low.extra]<extra_1[l]) & ((repl_estimation[[rep]]$extra[l,pos.high.extra]>extra_1[l])) )#
  {suma_extra[l]=suma_extra[l]+1}#
    }#
  }#
  Threshold_TF<-r_true>repl_estimation[[rep]]$thresholds[,2] & r_true<repl_estimation[[rep]]$thresholds[,3]#
  Include_Threshold<-matrix(as.integer(as.logical(Threshold_TF)),regimes-1,1)#
  suma_thresholds=suma_thresholds+Include_Threshold#
}
sesgo_thresholds<-dife_thresholds/n_rep#
#sesgo_thresholds#
#
divided<-function(x){x/10}#
prop_Reg1<-lapply(veces_est[[1]],fun)#
prop_Reg2<-lapply(veces_est[[2]],fun)#
#prop_Reg3<-lapply(veces_est[[3]],fun)#
#
###Percentage of time credible intervals captures real individual parameters table 1 respective column #
lapply(veces_est[[1]],divided)#
lapply(veces_est[[2]],divided)#
#
(table(delay)/n_rep)*100 ##Porcentaje de veces#
#suma_extra/n_rep#
prop.thresholds<-suma_thresholds/n_rep#
prop.delay<-table(delay)/n_rep#
#
prop.thresholds*100#
prop.delay*100
if(para.extra){#
prop.extra=suma_extra/n_rep#
sesgo_extra_def<-sesgo_extra/n_rep#
prop.extra*100#
sesgo_relativo_extra<-(sesgo_extra_def/abs(extra))*100#
sesgo_relativo_extra#
}#
##Relative Bias: extra and thresholds get Table 2#
#
sesgo_relativo_thresholds<-(sesgo_thresholds/abs(umbrales))*100#
sesgo_relativo_thresholds
rm(list = ls())
###load simulations for estimation, you can choose estimation with the true distribution or with any other, for instance#
### gaussian to get respective column of table 1 and also complete table 10,  this is the example for True distribution error student-t  for M1 model#
####If you have only one file con all the results of the simulations use:#
load("replicas_Identify_Dist_RelativeBias_Forecasting_1000_2reg_ForStudent.rds")#
#
###If you need to load each file and concatenate the outputs of the simulations use, however in this case that lines are with comment.#
####
#load("replicas_Identify_Dist_RelativeBias_Forecasting_1000_2reg_ForStudent.rds"")#
#
#repl_estimation<-repl_student_estimation#
#repl_compare_dist_todo<-repl_student_compare_dist#
#repl<-repl_student#
#
###Concatenate several files for Estimation and Credible Intervals #
#
#repl_estimation<-c(repl_estimation,repl_student_estimation)#
#
###Concatenate several files for simulations DIC and WAIC for compare distributions, name of the #
#
#repl_compare_dist_todo<-c(repl_compare_dist_todo,repl_student_compare_dist)#
#
##Concatenate several files for Forecasting n.ahead with TRUE distribution#
#
#repl<-c(repl,repl_student)#
any(sapply(repl_estimation, is.null)) ##Verify null entries#
any(sapply(repl, is.null)) ##Verify null entries#
any(sapply(repl_compare_dist_todo, is.null)) ##Verify null entries#
n_rep=1000 ###Set number of simulations#
fun = function(x){x/n_rep}#
regimes=2#
veces_est<-vector("list",regimes)#
longitud_est<-vector("list",regimes)#
sd_est<-vector("list",regimes)#
h.ahead=10#
k = 3 ##Dimension of the output vector#
v=2 ## Dimension of the exogenous variable vector#
ars <- list(p=c(1,2),q=c(1,0),d=c(1,0))#
###Create vectors for get counts#
veces<-vector("list",h.ahead)#
longitud<-vector("list",h.ahead)#
sd<-vector("list",h.ahead)#
###Counts for estimation ----#
for(reg in 1:regimes){#
  dime_inter<-dim(Rg[[reg]]$cs)#
  dime_phi=list()#
  for(orders in 1:ars$p[reg]){#
       dime_phi<-append(dime_phi,list(dim(Rg[[reg]]$Location$phi1)))#
     }#
  dime_sigma<-dim(Rg[[reg]]$Sigma)#
  suma_intercept<-matrix(rep(0,prod(dime_inter)),dime_inter[1],dime_inter[2])#
  suma_phi=list()#
  for(orders in 1:ars$p[reg]){#
    suma_phi<-append(suma_phi,list(matrix(rep(0,prod(dime_phi[[orders]])),dime_phi[[orders]][1],dime_phi[[orders]][2])))#
  }#
  if(reg==1)#
  {#
    dime_beta=list()#
    for(orders in 1:ars$q[reg]){#
      dime_beta<-append(dime_beta,list(dim(Rg[[reg]]$Location$beta1)))}#
    dime_delta=list()#
    for(orders in 1:ars$d[reg]){#
      dime_delta<-append(dime_delta,list(dim(Rg[[reg]]$Location$delta1)))}#
    suma_beta=list()#
    for(orders in 1:ars$p[reg]){#
      suma_beta<-append(suma_beta,list(matrix(rep(0,prod(dime_beta[[orders]])),dime_beta[[orders]][1],dime_beta[[orders]][2])))}#
      suma_delta=list()#
      for(orders in 1:ars$d[reg]){#
        suma_delta<-append(suma_delta,list(matrix(rep(0,prod(dime_delta[[orders]])),dime_delta[[orders]][1],dime_delta[[orders]][2])))}#
  } #
  suma_sigma<-matrix(rep(0,prod(dime_sigma)),dime_sigma[1],dime_sigma[2])#
  for(rep in 1:n_rep){#
    ###Autoregressive#
    row.names.obj_Reg_autoreg<-rownames(repl_estimation[[rep]]$non_structural[[reg]]$Autoregressive)#
    col.names.obj_Reg_autoreg<-colnames(repl_estimation[[rep]]$non_structural[[reg]]$Autoregressive)#
    pos.mean<-which(colnames(repl_estimation[[rep]]$non_structural[[reg]]$Autoregressive)==col.names.obj_Reg_autoreg[1])#
    pos.low<-which(colnames(repl_estimation[[rep]]$non_structural[[reg]]$Autoregressive)==col.names.obj_Reg_autoreg[4])#
    pos.high<-which(colnames(repl_estimation[[rep]]$non_structural[[reg]]$Autoregressive)==col.names.obj_Reg_autoreg[5])#
    pos.sd<-which(colnames(repl_estimation[[rep]]$non_structural[[reg]]$Autoregressive)==col.names.obj_Reg_autoreg[2])#
    ####IC#
    ###low#
    int.low_Reg<-repl_estimation[[rep]]$non_structural[[reg]]$Autoregressive[,pos.low]#
    int.low.intercep_Reg<-int.low_Reg[row.names.obj_Reg_autoreg[1],]#
    int.low_Phi_Reg<-t(int.low_Reg[row.names.obj_Reg_autoreg[2:(k+1)],])#
    if(ars$q[reg]!=0){#
    int.low_Beta_Reg<-t(int.low_Reg[row.names.obj_Reg_autoreg[(k+2):(k+1+v)],])#
    }#
    if(ars$d[reg]!=0){#
      int.low_Delta_Reg<-t(int.low_Reg[row.names.obj_Reg_autoreg[(k+1+v+1):(k+1+v+1)],])#
    }#
    ###high#
    int.high_Reg<-repl_estimation[[rep]]$non_structural[[reg]]$Autoregressive[,pos.high]#
    int.high.intercep_Reg<-int.high_Reg[row.names.obj_Reg_autoreg[1],]#
    int.high_Phi_Reg<-t(int.high_Reg[row.names.obj_Reg_autoreg[2:(k+1)],])#
    if(ars$p[reg]>1){#
      int.low_Phi2_Reg<-t(int.low_Reg[row.names.obj_Reg_autoreg[(k+2):(2*k+1)],])#
      int.high_Phi2_Reg<-t(int.high_Reg[row.names.obj_Reg_autoreg[(k+2):(2*k+1)],])#
    }#
    if(ars$q[reg]!=0){#
    int.high_Beta_Reg<-t(int.high_Reg[row.names.obj_Reg_autoreg[(k+2):(k+1+v)],])#
    }#
    if(ars$d[reg]!=0){#
      int.high_Delta_Reg<-t(int.high_Reg[row.names.obj_Reg_autoreg[(k+1+v+1):(k+1+v+1)],])#
    }#
    ####Phi#
    Phi_TF<-(int.low_Phi_Reg<Rg[[reg]]$Location$phi1) & (Rg[[reg]]$Location$phi1<int.high_Phi_Reg)#
    Include_Phi<- matrix(as.integer(as.logical(Phi_TF)),dime_phi[[reg]][1],dime_phi[[reg]][2])#
    suma_phi[[1]]<-suma_phi[[1]]+Include_Phi#
    if(reg==2){#
      Phi2_TF<-(int.low_Phi2_Reg<Rg[[reg]]$Location$phi2) & (Rg[[reg]]$Location$phi2<int.high_Phi2_Reg)#
      Include_Phi2<- matrix(as.integer(as.logical(Phi2_TF)),dime_phi[[reg]][1],dime_phi[[reg]][2])#
      suma_phi[[2]]<-suma_phi[[2]]+Include_Phi2  #
    }#
    ####Comparación#
    Intercept_TF<-(int.low.intercep_Reg<Rg[[reg]]$cs) & (Rg[[reg]]$cs<int.high.intercep_Reg)#
    Include_Intercept<- matrix(as.integer(as.logical(Intercept_TF)),dime_inter[1],dime_inter[2])#
    suma_intercept<-suma_intercept+Include_Intercept#
    ####Beta#
    if(ars$q[reg]!=0){#
    Beta_TF<-(int.low_Beta_Reg<Rg[[reg]]$Location$beta1) & (Rg[[reg]]$Location$beta1<int.high_Beta_Reg)#
    Include_Beta<- matrix(as.integer(as.logical(Beta_TF)),dime_beta[[reg]][1],dime_beta[[reg]][2])#
    suma_beta[[reg]]<-suma_beta[[reg]]+Include_Beta#
    }#
    ####Delta#
    if(ars$d[reg]!=0){#
      Delta_TF<-(int.low_Delta_Reg<t(Rg[[reg]]$Location$delta1)) & (t(Rg[[reg]]$Location$delta1)<int.high_Delta_Reg)#
      Include_Delta<- matrix(as.integer(as.logical(Delta_TF)),dime_delta[[reg]][1],dime_delta[[reg]][2])#
      suma_delta[[reg]]<-suma_delta[[reg]]+Include_Delta#
    }#
    ###Sigma#
    row.names.obj_Reg_scale<-rownames(repl_estimation[[rep]]$non_structural[[reg]]$Scale)#
    col.names.obj_Reg_scale<-colnames(repl_estimation[[rep]]$non_structural[[reg]]$Scale)#
    pos.mean_scale<-which(colnames(repl_estimation[[rep]]$non_structural[[reg]]$Scale)==col.names.obj_Reg_scale[1])#
    pos.low_scale<-which(colnames(repl_estimation[[rep]]$non_structural[[reg]]$Scale)==col.names.obj_Reg_scale[2])#
    pos.high_scale<-which(colnames(repl_estimation[[rep]]$non_structural[[reg]]$Scale)==col.names.obj_Reg_scale[3])#
    ####IC#
    ###low#
    int.low_Reg_scale<-repl_estimation[[rep]]$non_structural[[reg]]$Scale[,pos.low_scale]#
    int.low_Sigma_Reg<-t(int.low_Reg_scale)#
    ###high#
    int.high_Reg_scale<-repl_estimation[[rep]]$non_structural[[reg]]$Scale[,pos.high_scale]#
    int.high_Sigma_Reg<-t(int.high_Reg_scale)#
    ####Comparación#
    Sigma_TF<-(int.low_Sigma_Reg<(Rg[[reg]]$Sigma)) & ((Rg[[reg]]$Sigma)<int.high_Sigma_Reg)#
    Include_Sigma<- matrix(as.integer(as.logical(Sigma_TF)),dime_sigma[1],dime_sigma[2])#
    suma_sigma<-suma_sigma+Include_Sigma#
    print(rep)#
  }#
  if(reg==1){#
  veces_est[[reg]]<-list(Intercept=suma_intercept,Phi=suma_phi[[1]],Beta=suma_beta[[1]],Delta=suma_delta[[1]],Sigma=suma_sigma)#
  }#
  if(reg==2)#
  {veces_est[[reg]]<-list(Intercept=suma_intercept,Phi=suma_phi[[1]],Phi2=suma_phi[[2]],Sigma=suma_sigma)}#
}#
#
#para.extra=FALSE#
para.extra=TRUE#
if(isTRUE(para.extra)){#
#
extra_1<-extra#
suma_extra<-rep(0,length(extra_1))#
names.extra<-colnames(repl_estimation[[1]]$extra)#
pos.low.extra<-which(colnames(repl_estimation[[1]]$extra)==names.extra[4])#
pos.high.extra<-which(colnames(repl_estimation[[1]]$extra)==names.extra[5])#
sesgo_extra<-rep(0,length(extra_1))#
}#
suma_thresholds<-matrix(rep(0,regimes-1),regimes-1,1)#
dife_thresholds<-matrix(rep(0,regimes-1),regimes-1,1)#
r_true<-as.matrix(umbrales)#
delay<-rep(0,n_rep)#
#
for(rep in 1:n_rep){#
  dife_thresholds=dife_thresholds+(repl_estimation[[rep]]$thresholds[,1]-r_true)#
  delay[rep]<-repl_estimation[[rep]]$d#
  if(isTRUE(para.extra)){#
    for(l in 1:length(extra_1)){#
  	sesgo_extra=sesgo_extra+(repl_estimation[[rep]]$extra[,l]-extra_1)#
  if((repl_estimation[[rep]]$extra[l,pos.low.extra]<extra_1[l]) & ((repl_estimation[[rep]]$extra[l,pos.high.extra]>extra_1[l])) )#
  {suma_extra[l]=suma_extra[l]+1}#
    }#
  }#
  Threshold_TF<-r_true>repl_estimation[[rep]]$thresholds[,2] & r_true<repl_estimation[[rep]]$thresholds[,3]#
  Include_Threshold<-matrix(as.integer(as.logical(Threshold_TF)),regimes-1,1)#
  suma_thresholds=suma_thresholds+Include_Threshold#
}#
#
sesgo_thresholds<-dife_thresholds/n_rep#
#sesgo_thresholds#
#
divided<-function(x){x/10}#
prop_Reg1<-lapply(veces_est[[1]],fun)#
prop_Reg2<-lapply(veces_est[[2]],fun)
###Percentage of time credible intervals captures real individual parameters table 1 respective column #
lapply(veces_est[[1]],divided)#
lapply(veces_est[[2]],divided)
regimes=3#
n_rep=1000#
#
#####
#
###Load information, you shuold activate one of the following 6 lines and update the names in lines#
#load("replicas_gaussian_1000_3reg.rds")#
#load("replicas_student_1000_3reg.rds")#
#load("replicas_slash_1000_3reg.rds")#
#load("replicas_contaminated_1000_3reg.rds")#
#load("replicas_hyperbolic_1000_3reg.rds")#
load("replicas_laplace_1000_3reg.rds")#
## Estimation #
repl_estimation<-repl_laplace_estimation#
#
##Forecasting n.ahead with TRUE distribution#
repl<-repl_laplace#
###Concatene if it is necessary#
#repl_estimation<-c(repl_estimation,repl_slash_estimation)#
#repl<-c(repl,repl_slash)#
###Pronóstico#
fun = function(x){x/n_rep}#
veces<-vector("list",h.ahead)#
longitud<-vector("list",h.ahead)#
sd<-vector("list",h.ahead)#
#
######
#
veces_est<-vector("list",regimes)#
longitud_est<-vector("list",regimes)#
sd_est<-vector("list",regimes)#
#
###Parameters #
h.ahead=10#
k = 2 ##Dimension of the output vector#
v=0 ## Dimension of the exogenous variable vector#
ars <- list(p=c(1,1,1),q=c(0,0,0),d=c(0,0,0))#
delay <- 1#
#extra=5  #### Change for the TRUE parameter if it is necessary#
#
######Parameters#
Location_R1 = list(phi1 = matrix(c(0.8,0,-0.2,0.5),k,k,byrow = TRUE))#
Sigma_R1 = matrix(c(1,0,0,4),k,k,byrow = TRUE)#
#
cs_1=matrix(c(2,1),nrow=k)#
#
R1 = list(orders = list(p = 1,q = 0,d = 0),Location = Location_R1,Sigma = Sigma_R1,cs=cs_1)#
#
###Regimen 2#
#Location_R2 = list(phi1 = matrix(c(0.3,0,0,-0.6),k,k,byrow = TRUE),phi2 = matrix(c(-0.1,0,0,0.3),k,k,byrow = TRUE))#
Location_R2 = list(phi1 = matrix(c(0.3,0,0,-0.6),k,k,byrow = TRUE))#
Sigma_R2 = matrix(c(1,0,0,1),k,k,byrow = TRUE)#
#
cs_2=matrix(c(0.4,-2),nrow=k)#
#
R2 = list(orders = list(p = 1,q = 0,d = 0),#
          Location = Location_R2 ,Sigma = Sigma_R2,cs=cs_2)#
#
###R3 regimen#
#
#Location_R3 = list(phi1 = matrix(c(0.6,0,-0.2,0.8),k,k,byrow = TRUE),phi2 = matrix(c(0.2,0,0,-0.1),k,k,byrow = TRUE))#
Location_R3 = list(phi1 = matrix(c(0.6,0,-0.2,0.8),k,k,byrow = TRUE))#
Sigma_R3 = matrix(c(2,0,0,1),k,k,byrow = TRUE)#
#
cs_3=matrix(c(-3,0),nrow=k)#
R3 = list(orders = list(p = 1,q = 0,d = 0),#
          Location_ = Location_R3  ,Sigma = Sigma_R3,cs=cs_3)#
## crea lista de objeto tipo Regime#
Rg = list(R1 = R1,R2 = R2,R3=R3)#
###Estimación#
for(reg in 1:regimes){#
  dime_inter<-dim(Rg[[reg]]$cs)#
  dime_phi<-dim(Rg[[reg]]$Location$phi1)#
  dime_sigma<-dim(Rg[[reg]]$Sigma)#
  suma_intercept<-matrix(rep(0,prod(dime_inter)),dime_inter[1],dime_inter[2])#
  suma_phi<-matrix(rep(0,prod(dime_phi)),dime_phi[1],dime_phi[2])#
  suma_sigma<-matrix(rep(0,prod(dime_sigma)),dime_sigma[1],dime_sigma[2])#
  for(rep in 1:n_rep){#
    ###Autoregressive#
    row.names.obj_Reg_autoreg<-rownames(repl_estimation[[rep]]$non_structural[[reg]]$Autoregressive)#
    col.names.obj_Reg_autoreg<-colnames(repl_estimation[[rep]]$non_structural[[reg]]$Autoregressive)#
    pos.mean<-which(colnames(repl_estimation[[rep]]$non_structural[[reg]]$Autoregressive)==col.names.obj_Reg_autoreg[1])#
    pos.low<-which(colnames(repl_estimation[[rep]]$non_structural[[reg]]$Autoregressive)==col.names.obj_Reg_autoreg[4])#
    pos.high<-which(colnames(repl_estimation[[rep]]$non_structural[[reg]]$Autoregressive)==col.names.obj_Reg_autoreg[5])#
    pos.sd<-which(colnames(repl_estimation[[rep]]$non_structural[[reg]]$Autoregressive)==col.names.obj_Reg_autoreg[2])#
    ####IC#
    ###low#
    int.low_Reg<-repl_estimation[[rep]]$non_structural[[reg]]$Autoregressive[,pos.low]#
    int.low.intercep_Reg<-int.low_Reg[row.names.obj_Reg_autoreg[1],]#
    int.low_Phi_Reg<-t(int.low_Reg[row.names.obj_Reg_autoreg[2:(k+1)],])#
    ###high#
    int.high_Reg<-repl_estimation[[rep]]$non_structural[[reg]]$Autoregressive[,pos.high]#
    int.high.intercep_Reg<-int.high_Reg[row.names.obj_Reg_autoreg[1],]#
    int.high_Phi_Reg<-t(int.high_Reg[row.names.obj_Reg_autoreg[2:(k+1)],])#
    ####Comparación#
    Intercept_TF<-(int.low.intercep_Reg<Rg[[reg]]$cs) & (Rg[[reg]]$cs<int.high.intercep_Reg)#
    Include_Intercept<- matrix(as.integer(as.logical(Intercept_TF)),dime_inter[1],dime_inter[2])#
    suma_intercept<-suma_intercept+Include_Intercept#
    Phi_TF<-(int.low_Phi_Reg<Rg[[reg]]$Location$phi1) & (Rg[[reg]]$Location$phi1<int.high_Phi_Reg)#
    Include_Phi<- matrix(as.integer(as.logical(Phi_TF)),dime_phi[1],dime_phi[2])#
    suma_phi<-suma_phi+Include_Phi#
    ###Sigma#
    row.names.obj_Reg_scale<-rownames(repl_estimation[[rep]]$non_structural[[reg]]$Scale)#
    col.names.obj_Reg_scale<-colnames(repl_estimation[[rep]]$non_structural[[reg]]$Scale)#
    pos.mean_scale<-which(colnames(repl_estimation[[rep]]$non_structural[[reg]]$Scale)==col.names.obj_Reg_scale[1])#
    pos.low_scale<-which(colnames(repl_estimation[[rep]]$non_structural[[reg]]$Scale)==col.names.obj_Reg_scale[2])#
    pos.high_scale<-which(colnames(repl_estimation[[rep]]$non_structural[[reg]]$Scale)==col.names.obj_Reg_scale[3])#
    ####IC#
    ###low#
    int.low_Reg_scale<-repl_estimation[[rep]]$non_structural[[reg]]$Scale[,pos.low_scale]#
    int.low_Sigma_Reg<-t(int.low_Reg_scale)#
    ###high#
    int.high_Reg_scale<-repl_estimation[[rep]]$non_structural[[reg]]$Scale[,pos.high_scale]#
    int.high_Sigma_Reg<-t(int.high_Reg_scale)#
    ####Comparación#
    Sigma_TF<-(int.low_Sigma_Reg<(Rg[[reg]]$Sigma)) & ((Rg[[reg]]$Sigma)<int.high_Sigma_Reg)#
    Include_Sigma<- matrix(as.integer(as.logical(Sigma_TF)),dime_sigma[1],dime_sigma[2])#
    suma_sigma<-suma_sigma+Include_Sigma#
  }#
  veces_est[[reg]]<-list(Intercept=suma_intercept,Phi=suma_phi,Sigma=suma_sigma)#
}#
#
para.extra=FALSE #Depend if the distribution error has or nor extra parameter#
#
if(isTRUE(para.extra)){#
#
extra_1<-extra#
suma_extra<-rep(0,length(extra_1))#
names.extra<-colnames(repl_estimation[[1]]$extra)#
pos.low.extra<-which(colnames(repl_estimation[[1]]$extra)==names.extra[4])#
pos.high.extra<-which(colnames(repl_estimation[[1]]$extra)==names.extra[5])#
sesgo_extra<-rep(0,length(extra_1))#
}#
suma_thresholds<-matrix(rep(0,regimes-1),regimes-1,1)#
dife_thresholds<-matrix(rep(0,regimes-1),regimes-1,1)#
r_true<-as.matrix(umbrales)#
delay<-rep(0,n_rep)#
#
for(rep in 1:n_rep){#
  dife_thresholds=dife_thresholds+(repl_estimation[[rep]]$thresholds[,1]-r_true)#
  delay[rep]<-repl_estimation[[rep]]$d#
  if(isTRUE(para.extra)){#
    for(l in 1:length(extra_1)){#
  	sesgo_extra=sesgo_extra+(repl_estimation[[rep]]$extra[,l]-extra_1)#
  if((repl_estimation[[rep]]$extra[l,pos.low.extra]<extra_1[l]) & ((repl_estimation[[rep]]$extra[l,pos.high.extra]>extra_1[l])) )#
  {suma_extra[l]=suma_extra[l]+1}#
    }#
  }#
  Threshold_TF<-r_true>repl_estimation[[rep]]$thresholds[,2] & r_true<repl_estimation[[rep]]$thresholds[,3]#
  Include_Threshold<-matrix(as.integer(as.logical(Threshold_TF)),regimes-1,1)#
  suma_thresholds=suma_thresholds+Include_Threshold#
}#
sesgo_thresholds<-dife_thresholds/n_rep#
divided<-function(x){x/10}#
prop_Reg1<-lapply(veces_est[[1]],fun)#
prop_Reg2<-lapply(veces_est[[2]],fun)#
prop_Reg3<-lapply(veces_est[[3]],fun)#
#
###Percentage of time credible intervals captures real individual parameters table 1 respective column #
lapply(veces_est[[1]],divided)#
lapply(veces_est[[2]],divided)#
lapply(veces_est[[3]],divided)#
#suma_extra/n_rep#
prop.thresholds<-suma_thresholds/n_rep#
prop.delay<-table(delay)/n_rep#
#
prop.thresholds*100#
prop.delay*100#
###Sesgos relativos de los parámetros: extra and thresholds#
sesgo_relativo_extra<-(sesgo_extra_def/abs(extra))*100#
sesgo_relativo_thresholds<-(sesgo_thresholds/abs(umbrales))*100#
if(isTRUE(para.extra)){#
sesgo_extra_def<-sesgo_extra/n_rep#
prop.extra=suma_extra/n_rep#
prop.extra*100#
}#
#
#####Pronóstico#
for(pasos in 1:h.ahead){#
  suma_pasos=rep(0,k)#
  suma_longitud=rep(0,k)#
  #suma_sd=rep(0,k)#
  for(rep in 1:n_rep){#
    int.low.pos=which(names(repl[[rep]]$forecasting[pasos,])=="HDI_Low")#
    int.high.pos=which(names(repl[[rep]]$forecasting[pasos,])=="HDI_high")#
    #sd.pos=which(names(repl[[rep]]$forecasting[pasos,])=="SD")#
    for(entrada in 1:k){#
      if((repl[[rep]]$True_Values[pasos,entrada]>repl[[rep]]$forecasting[pasos,int.low.pos[entrada]])&(repl[[rep]]$True_Values[pasos,entrada]<repl[[rep]]$forecasting[pasos,int.high.pos[entrada]])){suma_pasos[entrada]=suma_pasos[entrada]+1}#
      suma_longitud[entrada]<-suma_longitud[entrada]+(repl[[rep]]$forecasting[pasos,int.high.pos[entrada]]-repl[[rep]]$forecasting[pasos,int.low.pos[entrada]])#
      #suma_sd[entrada]<-suma_sd[entrada]+repl[[rep]]$forecasting[pasos,sd.pos[entrada]]#
    }#
    #print(suma_longitud_gauss)#
    #print(suma_sd_gauss)#
  }#
  veces[[pasos]]=suma_pasos#
  longitud[[pasos]]=suma_longitud#
  #sd[[pasos]]=suma_sd#
}#
prop_pred_int<-lapply(veces,fun)#
#
mult<-function(x){x*100}#
###column of table 6#
print(lapply(prop_pred_int,mult),digits=3)
regimes=3#
n_rep=1000#
#
#####
#
###Load information, you shuold activate one of the following 6 lines and update the names in lines#
#load("replicas_gaussian_1000_3reg.rds")#
#load("replicas_student_1000_3reg.rds")#
#load("replicas_slash_1000_3reg.rds")#
#load("replicas_contaminated_1000_3reg.rds")#
#load("replicas_hyperbolic_1000_3reg.rds")#
load("replicas_laplace_1000_3reg.rds")#
## Estimation #
repl_estimation<-repl_laplace_estimation#
#
##Forecasting n.ahead with TRUE distribution#
repl<-repl_laplace#
###Concatene if it is necessary#
#repl_estimation<-c(repl_estimation,repl_slash_estimation)#
#repl<-c(repl,repl_slash)#
###Pronóstico#
fun = function(x){x/n_rep}#
veces<-vector("list",h.ahead)#
longitud<-vector("list",h.ahead)#
sd<-vector("list",h.ahead)#
#
######
#
veces_est<-vector("list",regimes)#
longitud_est<-vector("list",regimes)#
sd_est<-vector("list",regimes)#
#
###Parameters #
h.ahead=10#
k = 2 ##Dimension of the output vector#
v=0 ## Dimension of the exogenous variable vector#
ars <- list(p=c(1,1,1),q=c(0,0,0),d=c(0,0,0))#
delay <- 1#
#extra=5  #### Change for the TRUE parameter if it is necessary#
#
######Parameters#
Location_R1 = list(phi1 = matrix(c(0.8,0,-0.2,0.5),k,k,byrow = TRUE))#
Sigma_R1 = matrix(c(1,0,0,4),k,k,byrow = TRUE)#
#
cs_1=matrix(c(2,1),nrow=k)#
#
R1 = list(orders = list(p = 1,q = 0,d = 0),Location = Location_R1,Sigma = Sigma_R1,cs=cs_1)#
#
###Regimen 2#
#Location_R2 = list(phi1 = matrix(c(0.3,0,0,-0.6),k,k,byrow = TRUE),phi2 = matrix(c(-0.1,0,0,0.3),k,k,byrow = TRUE))#
Location_R2 = list(phi1 = matrix(c(0.3,0,0,-0.6),k,k,byrow = TRUE))#
Sigma_R2 = matrix(c(1,0,0,1),k,k,byrow = TRUE)#
#
cs_2=matrix(c(0.4,-2),nrow=k)#
#
R2 = list(orders = list(p = 1,q = 0,d = 0),#
          Location = Location_R2 ,Sigma = Sigma_R2,cs=cs_2)#
#
###R3 regimen#
#
#Location_R3 = list(phi1 = matrix(c(0.6,0,-0.2,0.8),k,k,byrow = TRUE),phi2 = matrix(c(0.2,0,0,-0.1),k,k,byrow = TRUE))#
Location_R3 = list(phi1 = matrix(c(0.6,0,-0.2,0.8),k,k,byrow = TRUE))#
Sigma_R3 = matrix(c(2,0,0,1),k,k,byrow = TRUE)#
#
cs_3=matrix(c(-3,0),nrow=k)#
R3 = list(orders = list(p = 1,q = 0,d = 0),#
          Location_ = Location_R3  ,Sigma = Sigma_R3,cs=cs_3)#
## crea lista de objeto tipo Regime#
Rg = list(R1 = R1,R2 = R2,R3=R3)#
###Estimación#
for(reg in 1:regimes){#
  dime_inter<-dim(Rg[[reg]]$cs)#
  dime_phi<-dim(Rg[[reg]]$Location$phi1)#
  dime_sigma<-dim(Rg[[reg]]$Sigma)#
  suma_intercept<-matrix(rep(0,prod(dime_inter)),dime_inter[1],dime_inter[2])#
  suma_phi<-matrix(rep(0,prod(dime_phi)),dime_phi[1],dime_phi[2])#
  suma_sigma<-matrix(rep(0,prod(dime_sigma)),dime_sigma[1],dime_sigma[2])#
  for(rep in 1:n_rep){#
    ###Autoregressive#
    row.names.obj_Reg_autoreg<-rownames(repl_estimation[[rep]]$non_structural[[reg]]$Autoregressive)#
    col.names.obj_Reg_autoreg<-colnames(repl_estimation[[rep]]$non_structural[[reg]]$Autoregressive)#
    pos.mean<-which(colnames(repl_estimation[[rep]]$non_structural[[reg]]$Autoregressive)==col.names.obj_Reg_autoreg[1])#
    pos.low<-which(colnames(repl_estimation[[rep]]$non_structural[[reg]]$Autoregressive)==col.names.obj_Reg_autoreg[4])#
    pos.high<-which(colnames(repl_estimation[[rep]]$non_structural[[reg]]$Autoregressive)==col.names.obj_Reg_autoreg[5])#
    pos.sd<-which(colnames(repl_estimation[[rep]]$non_structural[[reg]]$Autoregressive)==col.names.obj_Reg_autoreg[2])#
    ####IC#
    ###low#
    int.low_Reg<-repl_estimation[[rep]]$non_structural[[reg]]$Autoregressive[,pos.low]#
    int.low.intercep_Reg<-int.low_Reg[row.names.obj_Reg_autoreg[1],]#
    int.low_Phi_Reg<-t(int.low_Reg[row.names.obj_Reg_autoreg[2:(k+1)],])#
    ###high#
    int.high_Reg<-repl_estimation[[rep]]$non_structural[[reg]]$Autoregressive[,pos.high]#
    int.high.intercep_Reg<-int.high_Reg[row.names.obj_Reg_autoreg[1],]#
    int.high_Phi_Reg<-t(int.high_Reg[row.names.obj_Reg_autoreg[2:(k+1)],])#
    ####Comparación#
    Intercept_TF<-(int.low.intercep_Reg<Rg[[reg]]$cs) & (Rg[[reg]]$cs<int.high.intercep_Reg)#
    Include_Intercept<- matrix(as.integer(as.logical(Intercept_TF)),dime_inter[1],dime_inter[2])#
    suma_intercept<-suma_intercept+Include_Intercept#
    Phi_TF<-(int.low_Phi_Reg<Rg[[reg]]$Location$phi1) & (Rg[[reg]]$Location$phi1<int.high_Phi_Reg)#
    Include_Phi<- matrix(as.integer(as.logical(Phi_TF)),dime_phi[1],dime_phi[2])#
    suma_phi<-suma_phi+Include_Phi#
    ###Sigma#
    row.names.obj_Reg_scale<-rownames(repl_estimation[[rep]]$non_structural[[reg]]$Scale)#
    col.names.obj_Reg_scale<-colnames(repl_estimation[[rep]]$non_structural[[reg]]$Scale)#
    pos.mean_scale<-which(colnames(repl_estimation[[rep]]$non_structural[[reg]]$Scale)==col.names.obj_Reg_scale[1])#
    pos.low_scale<-which(colnames(repl_estimation[[rep]]$non_structural[[reg]]$Scale)==col.names.obj_Reg_scale[2])#
    pos.high_scale<-which(colnames(repl_estimation[[rep]]$non_structural[[reg]]$Scale)==col.names.obj_Reg_scale[3])#
    ####IC#
    ###low#
    int.low_Reg_scale<-repl_estimation[[rep]]$non_structural[[reg]]$Scale[,pos.low_scale]#
    int.low_Sigma_Reg<-t(int.low_Reg_scale)#
    ###high#
    int.high_Reg_scale<-repl_estimation[[rep]]$non_structural[[reg]]$Scale[,pos.high_scale]#
    int.high_Sigma_Reg<-t(int.high_Reg_scale)#
    ####Comparación#
    Sigma_TF<-(int.low_Sigma_Reg<(Rg[[reg]]$Sigma)) & ((Rg[[reg]]$Sigma)<int.high_Sigma_Reg)#
    Include_Sigma<- matrix(as.integer(as.logical(Sigma_TF)),dime_sigma[1],dime_sigma[2])#
    suma_sigma<-suma_sigma+Include_Sigma#
  }#
  veces_est[[reg]]<-list(Intercept=suma_intercept,Phi=suma_phi,Sigma=suma_sigma)#
}#
#
para.extra=FALSE #Depend if the distribution error has or nor extra parameter#
#
if(isTRUE(para.extra)){#
#
extra_1<-extra#
suma_extra<-rep(0,length(extra_1))#
names.extra<-colnames(repl_estimation[[1]]$extra)#
pos.low.extra<-which(colnames(repl_estimation[[1]]$extra)==names.extra[4])#
pos.high.extra<-which(colnames(repl_estimation[[1]]$extra)==names.extra[5])#
sesgo_extra<-rep(0,length(extra_1))#
}#
suma_thresholds<-matrix(rep(0,regimes-1),regimes-1,1)#
dife_thresholds<-matrix(rep(0,regimes-1),regimes-1,1)#
r_true<-as.matrix(umbrales)#
delay<-rep(0,n_rep)#
#
for(rep in 1:n_rep){#
  dife_thresholds=dife_thresholds+(repl_estimation[[rep]]$thresholds[,1]-r_true)#
  delay[rep]<-repl_estimation[[rep]]$d#
  if(isTRUE(para.extra)){#
    for(l in 1:length(extra_1)){#
  	sesgo_extra=sesgo_extra+(repl_estimation[[rep]]$extra[,l]-extra_1)#
  if((repl_estimation[[rep]]$extra[l,pos.low.extra]<extra_1[l]) & ((repl_estimation[[rep]]$extra[l,pos.high.extra]>extra_1[l])) )#
  {suma_extra[l]=suma_extra[l]+1}#
    }#
  }#
  Threshold_TF<-r_true>repl_estimation[[rep]]$thresholds[,2] & r_true<repl_estimation[[rep]]$thresholds[,3]#
  Include_Threshold<-matrix(as.integer(as.logical(Threshold_TF)),regimes-1,1)#
  suma_thresholds=suma_thresholds+Include_Threshold#
}#
sesgo_thresholds<-dife_thresholds/n_rep#
divided<-function(x){x/10}#
prop_Reg1<-lapply(veces_est[[1]],fun)#
prop_Reg2<-lapply(veces_est[[2]],fun)#
prop_Reg3<-lapply(veces_est[[3]],fun)#
#
###Percentage of time credible intervals captures real individual parameters table 1 respective column #
lapply(veces_est[[1]],divided)#
lapply(veces_est[[2]],divided)#
lapply(veces_est[[3]],divided)#
#suma_extra/n_rep#
prop.thresholds<-suma_thresholds/n_rep#
prop.delay<-table(delay)/n_rep#
#
prop.thresholds*100#
prop.delay*100#
###Sesgos relativos de los parámetros: extra and thresholds#
sesgo_relativo_extra<-(sesgo_extra_def/abs(extra))*100#
sesgo_relativo_thresholds<-(sesgo_thresholds/abs(umbrales))*100#
if(isTRUE(para.extra)){#
sesgo_extra_def<-sesgo_extra/n_rep#
prop.extra=suma_extra/n_rep#
prop.extra*100#
}#
#
#####Pronóstico#
for(pasos in 1:h.ahead){#
  suma_pasos=rep(0,k)#
  suma_longitud=rep(0,k)#
  #suma_sd=rep(0,k)#
  for(rep in 1:n_rep){#
    int.low.pos=which(names(repl[[rep]]$forecasting[pasos,])=="HDI_Low")#
    int.high.pos=which(names(repl[[rep]]$forecasting[pasos,])=="HDI_high")#
    #sd.pos=which(names(repl[[rep]]$forecasting[pasos,])=="SD")#
    for(entrada in 1:k){#
      if((repl[[rep]]$True_Values[pasos,entrada]>repl[[rep]]$forecasting[pasos,int.low.pos[entrada]])&(repl[[rep]]$True_Values[pasos,entrada]<repl[[rep]]$forecasting[pasos,int.high.pos[entrada]])){suma_pasos[entrada]=suma_pasos[entrada]+1}#
      suma_longitud[entrada]<-suma_longitud[entrada]+(repl[[rep]]$forecasting[pasos,int.high.pos[entrada]]-repl[[rep]]$forecasting[pasos,int.low.pos[entrada]])#
      #suma_sd[entrada]<-suma_sd[entrada]+repl[[rep]]$forecasting[pasos,sd.pos[entrada]]#
    }#
    #print(suma_longitud_gauss)#
    #print(suma_sd_gauss)#
  }#
  veces[[pasos]]=suma_pasos#
  longitud[[pasos]]=suma_longitud#
  #sd[[pasos]]=suma_sd#
}#
prop_pred_int<-lapply(veces,fun)#
#
mult<-function(x){x*100}#
###column of table 6#
print(lapply(prop_pred_int,mult),digits=3)
####Resumen de las 1000 réplicas#
######
#rm(list = ls())#
regimes=3#
n_rep=1000#
#
#####
#
###Load information, you shuold activate one of the following 6 lines and update the names in lines#
#load("replicas_gaussian_1000_3reg.rds")#
#load("replicas_student_1000_3reg.rds")#
#load("replicas_slash_1000_3reg.rds")#
#load("replicas_contaminated_1000_3reg.rds")#
#load("replicas_hyperbolic_1000_3reg.rds")#
load("replicas_laplace_1000_3reg.rds")#
## Estimation #
repl_estimation<-repl_laplace_estimation#
#
##Forecasting n.ahead with TRUE distribution#
repl<-repl_laplace#
###Concatene if it is necessary#
#repl_estimation<-c(repl_estimation,repl_slash_estimation)#
#repl<-c(repl,repl_slash)#
###Pronóstico#
fun = function(x){x/n_rep}#
veces<-vector("list",h.ahead)#
longitud<-vector("list",h.ahead)#
sd<-vector("list",h.ahead)#
#
######
#
veces_est<-vector("list",regimes)#
longitud_est<-vector("list",regimes)#
sd_est<-vector("list",regimes)#
#
###Parameters #
h.ahead=10#
k = 2 ##Dimension of the output vector#
v=0 ## Dimension of the exogenous variable vector#
ars <- list(p=c(1,1,1),q=c(0,0,0),d=c(0,0,0))#
delay <- 1#
#extra=5  #### Change for the TRUE parameter if it is necessary#
#
######Parameters#
Location_R1 = list(phi1 = matrix(c(0.8,0,-0.2,0.5),k,k,byrow = TRUE))#
Sigma_R1 = matrix(c(1,0,0,4),k,k,byrow = TRUE)#
#
cs_1=matrix(c(2,1),nrow=k)#
#
R1 = list(orders = list(p = 1,q = 0,d = 0),Location = Location_R1,Sigma = Sigma_R1,cs=cs_1)#
#
###Regimen 2#
#Location_R2 = list(phi1 = matrix(c(0.3,0,0,-0.6),k,k,byrow = TRUE),phi2 = matrix(c(-0.1,0,0,0.3),k,k,byrow = TRUE))#
Location_R2 = list(phi1 = matrix(c(0.3,0,0,-0.6),k,k,byrow = TRUE))#
Sigma_R2 = matrix(c(1,0,0,1),k,k,byrow = TRUE)#
#
cs_2=matrix(c(0.4,-2),nrow=k)#
#
R2 = list(orders = list(p = 1,q = 0,d = 0),#
          Location = Location_R2 ,Sigma = Sigma_R2,cs=cs_2)#
#
###R3 regimen#
#
#Location_R3 = list(phi1 = matrix(c(0.6,0,-0.2,0.8),k,k,byrow = TRUE),phi2 = matrix(c(0.2,0,0,-0.1),k,k,byrow = TRUE))#
Location_R3 = list(phi1 = matrix(c(0.6,0,-0.2,0.8),k,k,byrow = TRUE))#
Sigma_R3 = matrix(c(2,0,0,1),k,k,byrow = TRUE)#
#
cs_3=matrix(c(-3,0),nrow=k)#
R3 = list(orders = list(p = 1,q = 0,d = 0),#
          Location_ = Location_R3  ,Sigma = Sigma_R3,cs=cs_3)#
## crea lista de objeto tipo Regime#
Rg = list(R1 = R1,R2 = R2,R3=R3)#
###Estimación#
for(reg in 1:regimes){#
  dime_inter<-dim(Rg[[reg]]$cs)#
  dime_phi<-dim(Rg[[reg]]$Location$phi1)#
  dime_sigma<-dim(Rg[[reg]]$Sigma)#
  suma_intercept<-matrix(rep(0,prod(dime_inter)),dime_inter[1],dime_inter[2])#
  suma_phi<-matrix(rep(0,prod(dime_phi)),dime_phi[1],dime_phi[2])#
  suma_sigma<-matrix(rep(0,prod(dime_sigma)),dime_sigma[1],dime_sigma[2])#
  for(rep in 1:n_rep){#
    ###Autoregressive#
    row.names.obj_Reg_autoreg<-rownames(repl_estimation[[rep]]$non_structural[[reg]]$Autoregressive)#
    col.names.obj_Reg_autoreg<-colnames(repl_estimation[[rep]]$non_structural[[reg]]$Autoregressive)#
    pos.mean<-which(colnames(repl_estimation[[rep]]$non_structural[[reg]]$Autoregressive)==col.names.obj_Reg_autoreg[1])#
    pos.low<-which(colnames(repl_estimation[[rep]]$non_structural[[reg]]$Autoregressive)==col.names.obj_Reg_autoreg[4])#
    pos.high<-which(colnames(repl_estimation[[rep]]$non_structural[[reg]]$Autoregressive)==col.names.obj_Reg_autoreg[5])#
    pos.sd<-which(colnames(repl_estimation[[rep]]$non_structural[[reg]]$Autoregressive)==col.names.obj_Reg_autoreg[2])#
    ####IC#
    ###low#
    int.low_Reg<-repl_estimation[[rep]]$non_structural[[reg]]$Autoregressive[,pos.low]#
    int.low.intercep_Reg<-int.low_Reg[row.names.obj_Reg_autoreg[1],]#
    int.low_Phi_Reg<-t(int.low_Reg[row.names.obj_Reg_autoreg[2:(k+1)],])#
    ###high#
    int.high_Reg<-repl_estimation[[rep]]$non_structural[[reg]]$Autoregressive[,pos.high]#
    int.high.intercep_Reg<-int.high_Reg[row.names.obj_Reg_autoreg[1],]#
    int.high_Phi_Reg<-t(int.high_Reg[row.names.obj_Reg_autoreg[2:(k+1)],])#
    ####Comparación#
    Intercept_TF<-(int.low.intercep_Reg<Rg[[reg]]$cs) & (Rg[[reg]]$cs<int.high.intercep_Reg)#
    Include_Intercept<- matrix(as.integer(as.logical(Intercept_TF)),dime_inter[1],dime_inter[2])#
    suma_intercept<-suma_intercept+Include_Intercept#
    Phi_TF<-(int.low_Phi_Reg<Rg[[reg]]$Location$phi1) & (Rg[[reg]]$Location$phi1<int.high_Phi_Reg)#
    Include_Phi<- matrix(as.integer(as.logical(Phi_TF)),dime_phi[1],dime_phi[2])#
    suma_phi<-suma_phi+Include_Phi#
    ###Sigma#
    row.names.obj_Reg_scale<-rownames(repl_estimation[[rep]]$non_structural[[reg]]$Scale)#
    col.names.obj_Reg_scale<-colnames(repl_estimation[[rep]]$non_structural[[reg]]$Scale)#
    pos.mean_scale<-which(colnames(repl_estimation[[rep]]$non_structural[[reg]]$Scale)==col.names.obj_Reg_scale[1])#
    pos.low_scale<-which(colnames(repl_estimation[[rep]]$non_structural[[reg]]$Scale)==col.names.obj_Reg_scale[2])#
    pos.high_scale<-which(colnames(repl_estimation[[rep]]$non_structural[[reg]]$Scale)==col.names.obj_Reg_scale[3])#
    ####IC#
    ###low#
    int.low_Reg_scale<-repl_estimation[[rep]]$non_structural[[reg]]$Scale[,pos.low_scale]#
    int.low_Sigma_Reg<-t(int.low_Reg_scale)#
    ###high#
    int.high_Reg_scale<-repl_estimation[[rep]]$non_structural[[reg]]$Scale[,pos.high_scale]#
    int.high_Sigma_Reg<-t(int.high_Reg_scale)#
    ####Comparación#
    Sigma_TF<-(int.low_Sigma_Reg<(Rg[[reg]]$Sigma)) & ((Rg[[reg]]$Sigma)<int.high_Sigma_Reg)#
    Include_Sigma<- matrix(as.integer(as.logical(Sigma_TF)),dime_sigma[1],dime_sigma[2])#
    suma_sigma<-suma_sigma+Include_Sigma#
  }#
  veces_est[[reg]]<-list(Intercept=suma_intercept,Phi=suma_phi,Sigma=suma_sigma)#
}#
#
para.extra=FALSE #Depend if the distribution error has or nor extra parameter#
#
if(isTRUE(para.extra)){#
#
extra_1<-extra#
suma_extra<-rep(0,length(extra_1))#
names.extra<-colnames(repl_estimation[[1]]$extra)#
pos.low.extra<-which(colnames(repl_estimation[[1]]$extra)==names.extra[4])#
pos.high.extra<-which(colnames(repl_estimation[[1]]$extra)==names.extra[5])#
sesgo_extra<-rep(0,length(extra_1))#
}#
suma_thresholds<-matrix(rep(0,regimes-1),regimes-1,1)#
dife_thresholds<-matrix(rep(0,regimes-1),regimes-1,1)#
r_true<-as.matrix(umbrales)#
delay<-rep(0,n_rep)#
#
for(rep in 1:n_rep){#
  dife_thresholds=dife_thresholds+(repl_estimation[[rep]]$thresholds[,1]-r_true)#
  delay[rep]<-repl_estimation[[rep]]$d#
  if(isTRUE(para.extra)){#
    for(l in 1:length(extra_1)){#
  	sesgo_extra=sesgo_extra+(repl_estimation[[rep]]$extra[,l]-extra_1)#
  if((repl_estimation[[rep]]$extra[l,pos.low.extra]<extra_1[l]) & ((repl_estimation[[rep]]$extra[l,pos.high.extra]>extra_1[l])) )#
  {suma_extra[l]=suma_extra[l]+1}#
    }#
  }#
  Threshold_TF<-r_true>repl_estimation[[rep]]$thresholds[,2] & r_true<repl_estimation[[rep]]$thresholds[,3]#
  Include_Threshold<-matrix(as.integer(as.logical(Threshold_TF)),regimes-1,1)#
  suma_thresholds=suma_thresholds+Include_Threshold#
}#
sesgo_thresholds<-dife_thresholds/n_rep#
divided<-function(x){x/10}#
prop_Reg1<-lapply(veces_est[[1]],fun)#
prop_Reg2<-lapply(veces_est[[2]],fun)#
prop_Reg3<-lapply(veces_est[[3]],fun)#
#
###Percentage of time credible intervals captures real individual parameters table 1 respective column #
lapply(veces_est[[1]],divided)#
lapply(veces_est[[2]],divided)#
lapply(veces_est[[3]],divided)#
#suma_extra/n_rep#
prop.thresholds<-suma_thresholds/n_rep#
prop.delay<-table(delay)/n_rep#
#
prop.thresholds*100#
prop.delay*100#
###Sesgos relativos de los parámetros: extra and thresholds#
#
sesgo_relativo_thresholds<-(sesgo_thresholds/abs(umbrales))*100#
sesgo_relativo_thresholds#
#
if(isTRUE(para.extra)){#
sesgo_relativo_extra<-(sesgo_extra_def/abs(extra))*100#
sesgo_extra_def<-sesgo_extra/n_rep#
prop.extra=suma_extra/n_rep#
prop.extra*100#
sesgo_relativo_extra#
}#
#
#####Pronóstico#
for(pasos in 1:h.ahead){#
  suma_pasos=rep(0,k)#
  suma_longitud=rep(0,k)#
  #suma_sd=rep(0,k)#
  for(rep in 1:n_rep){#
    int.low.pos=which(names(repl[[rep]]$forecasting[pasos,])=="HDI_Low")#
    int.high.pos=which(names(repl[[rep]]$forecasting[pasos,])=="HDI_high")#
    #sd.pos=which(names(repl[[rep]]$forecasting[pasos,])=="SD")#
    for(entrada in 1:k){#
      if((repl[[rep]]$True_Values[pasos,entrada]>repl[[rep]]$forecasting[pasos,int.low.pos[entrada]])&(repl[[rep]]$True_Values[pasos,entrada]<repl[[rep]]$forecasting[pasos,int.high.pos[entrada]])){suma_pasos[entrada]=suma_pasos[entrada]+1}#
      suma_longitud[entrada]<-suma_longitud[entrada]+(repl[[rep]]$forecasting[pasos,int.high.pos[entrada]]-repl[[rep]]$forecasting[pasos,int.low.pos[entrada]])#
      #suma_sd[entrada]<-suma_sd[entrada]+repl[[rep]]$forecasting[pasos,sd.pos[entrada]]#
    }#
    #print(suma_longitud_gauss)#
    #print(suma_sd_gauss)#
  }#
  veces[[pasos]]=suma_pasos#
  longitud[[pasos]]=suma_longitud#
  #sd[[pasos]]=suma_sd#
}#
prop_pred_int<-lapply(veces,fun)#
#
mult<-function(x){x*100}#
###column of table 6#
print(lapply(prop_pred_int,mult),digits=3)
regimes=3#
n_rep=1000#
#
#####
#
###Load information, you shuold activate one of the following 6 lines and update the names in lines#
#load("replicas_gaussian_1000_3reg1.rds")#
#load("replicas_student_1000_3reg1.rds")#
#load("replicas_slash_1000_3reg1.rds")#
#load("replicas_contaminated_1000_3reg1.rds")#
#load("replicas_hyperbolic_1000_3reg1.rds")#
load("replicas_laplace_1000_3reg1.rds")#
## Estimation for selected distribution#
repl_estimation<-repl_laplace_estimation#
#
##Forecasting n.ahead with selected distribution#
repl<-repl_laplace
rm(list())
rm(list = ls())
####Program for simulating MTAR process and estimating its parameters#
###This only includes M2 structure model, that is bivariate a MTAR with 3 regimes#
###This an example for simulating and estimating a MTAR model with distribution error Slash with parameterx extra 4.#
#
# Required packages====#
#
library(GIGrvg)#
library(Formula)#
library(Rfast)#
library(expm)#
library(mtar)#
library(ltsa)#
####Defining parameters of the model and  lists for storing the results====#
n_rep=100 ##number of replications#
#repl_student<-vector("list", n_rep)#
#repl_gaussian<-vector("list", n_rep)#
#repl_laplace<-vector("list", n_rep)#
#
#repl_student_estimation<-vector("list", n_rep)#
#repl_gaussian_estimation<-vector("list", n_rep)#
#repl_laplace_estimation<-vector("list", n_rep)#
#repl_hyperbolic<-vector("list", n_rep)#
repl_slash<-vector("list", n_rep)#
#repl_contaminated<-vector("list", n_rep)#
#
#repl_hyperbolic_estimation<-vector("list", n_rep)#
repl_slash_estimation<-vector("list", n_rep)#
#repl_contaminated_estimation<-vector("list", n_rep)#
calen=100 ## Starting values#
long=1000 ##Long of Series#
h.ahead=10 ## forecast horizon#
Tlen = long+calen+h.ahead#
##Parameters of the  Process Yt ====#
k = 2#
v=0#
###Function for simulating arma model with constant #
simulate_arma <- function(ar_params = NULL, ma_params = NULL, constant = 0, n = 100, sigma2 = 1){ #
  # Load necessary library#
  library(stats)#
  # Validate input#
  if (is.null(ar_params) && is.null(ma_params)) {#
    stop("Please specify either AR or MA parameters.")#
  }#
  # Generate innovation series#
  innovations <- rnorm(n, mean = 0, sd = sqrt(sigma2))#
  # Initialize series#
  arma_series <- numeric(n)#
  # Handle initial values for AR components#
  if (!is.null(ar_params)) {#
    arma_series[1:max(length(ar_params), 1)] <- innovations[1:max(length(ar_params), 1)]#
  }#
  # Simulate the ARMA process#
  for (t in (max(length(ar_params), 1) + 1):n) {#
    ar_part <- ifelse(is.null(ar_params), 0, sum(ar_params * arma_series[(t - 1):(t - length(ar_params))]))#
    ma_part <- ifelse(is.null(ma_params), 0, sum(ma_params * innovations[(t - 1):(t - length(ma_params))]))#
    arma_series[t] <- constant + ar_part + ma_part + innovations[t]#
  }#
  return(arma_series)#
}#
###Structural parameters and parameters for the exogenous and threshold processes#
dist <- "Slash"#
#extra <- c(0.012,0.08)#
#extra<-c(0.1,0.15)#
extra=4#
delay <- 1#
Intercept <- TRUE#
ars <- list(p=c(1,1,1),q=c(0,0,0),d=c(0,0,0))#
inic<-calen#
phi_ar=0.6#
sigma2_inn_ar<-1#
constant<-1#
### Paramaters of the R1 regime ====#
Location_R1 = list(phi1 = matrix(c(0.8,0,-0.2,0.5),k,k,byrow = TRUE))#
#
Sigma_R1 = matrix(c(1,0,0,4),k,k,byrow = TRUE)#
#
cs_1=matrix(c(2,1),nrow=k)#
#
R1 = list(orders = list(p = 1,q = 0,d = 0),Location = Location_R1,Sigma = Sigma_R1,cs=cs_1)#
#
###Parameters of the R3 regimen#
Location_R2 = list(phi1 = matrix(c(0.3,0,0,-0.6),k,k,byrow = TRUE))#
#
Sigma_R2 = matrix(c(1,0,0,1),k,k,byrow = TRUE)#
#
cs_2=matrix(c(0.4,-2),nrow=k)#
#
R2 = list(orders = list(p = 1,q = 0,d = 0),#
          Location = Location_R2 ,Sigma = Sigma_R2,cs=cs_2)#
#
###Parameters of the R3 regimen#
#
Location_R3 = list(phi1 = matrix(c(0.6,0,-0.2,0.8),k,k,byrow = TRUE))#
Sigma_R3 = matrix(c(2,0,0,1),k,k,byrow = TRUE)#
#
cs_3=matrix(c(-3,0),nrow=k)#
R3 = list(orders = list(p = 1,q = 0,d = 0),#
          Location_ = Location_R3  ,Sigma = Sigma_R3,cs=cs_3)#
## list of the #
Rg = list(R1 = R1,R2 = R2,R3=R3)#
####Mean and Variace ARMA#
mean_arma=constant/(1-sum(phi_ar))#
#
var_arma<-ltsa::tacvfARMA(phi=phi_ar,sigma2=sigma2_inn_ar)[1]#
#
params <- list()#
umbrales<-qnorm(p=c(0.33,0.66),mean =mean_arma,sd = sqrt(var_arma) ) ##Thoeretical thresholds #
###Creates a list of structural parameters to be used for the simulation #
#
for(i in 1:length(ars$p)){#
  np <- Intercept + ars$p[i]*k + ars$q[i]*v + ars$d[i]#
  params[[i]] <- list()#
  params[[i]]$location <-rbind(t(Rg[[i]][[4]]),matrix(unlist(Rg[[i]][[2]]),ncol=k,byrow=TRUE))#
  #params[[i]]$location <- matrix(c(rbeta(np*k,shape1=4,shape2=16)),np,k)#
  # params[[i]]$scale <- diag(rgamma(k,shape=1,scale=1))#
  params[[i]]$scale <- Rg[[i]][[3]]#
  params[[i]]$scale2 <- chol(params[[i]]$scale)#
}#
params#
start.time <- Sys.time()#
bar <- txtProgressBar(min=0, max=n_rep, initial=0, char="=", style=3)#
for(replicas in 1:n_rep){#
  ## 3 dimensions ====#
  ## Simulating the process Zt#
  Zt<-tseries  <- simulate_arma(ar_params = phi_ar, constant = constant, sigma2 = sigma2_inn_ar,n = Tlen+max(ars$p,ars$q,ars$d,delay))#
  myseries <- matrix(0,Tlen+max(ars$p,ars$q,ars$d,delay),k)#
  regimen <- cut(Zt[(max(ars$p,ars$q,ars$d,delay)+1-delay):(length(Zt)-delay)],breaks=c(-Inf,umbrales,Inf),labels=1:length(ars$p))#
  myseries[1:max(ars$p,ars$q,ars$d),] <- rnorm(max(ars$p,ars$q,ars$d)*k)#
  for(i in 1:Tlen){#
    current <- max(ars$p,ars$q,ars$d,delay) + i#
    regimeni <- regimen[i]#
    if(Intercept) X <- 1 else X <-  vector()#
    for(j in 1:ars$p[regimeni]) X <- c(X,myseries[current-j,])#
    if(ars$q[regimeni] > 0) for(j in 1:ars$q[regimeni]) X <- c(X,Xt[current-j,])#
    if(ars$d[regimeni] > 0) for(j in 1:ars$d[regimeni]) X <- c(X,Zt[current-j,])#
    Theta <- params[[regimeni]]$location   #
    mu <- apply(matrix(X,nrow(Theta),ncol(Theta))*Theta,2,sum)#
    u <- 1#
    if(dist=="Student-t")  u <- 1/rgamma(1,shape=extra/2,rate=extra/2)#
    if(dist=="Slash")  u <- 1/rbeta(1,shape1=extra/2,shape2=1)#
    if(dist=="Contaminated normal")  if(runif(1)<=extra[1]) u <- 1/extra[2]#
    if(dist=="Laplace")  u <- rexp(1,rate=1/8)#
    if(dist=="Hyperbolic") u <- rgig(n=1,lambda=1,chi=1,psi=extra^2)#
    myseries[current,] <- t(params[[regimeni]]$scale2)%*%matrix(rnorm(k,mean=0,sd=sqrt(u)),k,1) + matrix(mu,k,1)#
  }#
  datos <- data.frame(myseries[(max(ars$p,ars$q,ars$d,delay)+inic+1):length(Zt),])#
  colnames(datos) <- paste("X",1:k,sep="")#
  datos <- data.frame(datos,threshold=Zt[(max(ars$p,ars$q,ars$d,delay)+inic+1):length(Zt)])#
  if(max(ars$q)>0){#
    colnames(Xt) <- paste("X",(k+1):(k+v),sep="")#
    datos <- data.frame(datos,Xt[(max(ars$p,ars$q,ars$d,delay)+inic+1):length(Zt),])#
  }#
  ### Creating dates for simulating time serie data====#
  Fechas=seq(as.Date("2000/1/1"), by = "day", length.out = (Tlen-calen))#
  #### 3 reg defining long of series ====#
  datos1=data.frame(datos,Fecha=Fechas)#
    fecha_final<-Fechas[long]#
    ##  Procedure for estimating parameters using function mtar of the mtarm R package====#
  ###########
  fit1_Bayes <- mtar(~X1+X2|threshold, data=datos1, row.names=Fecha,subset={Fecha<=fecha_final} ,ars=ars, dist=dist, n.burnin=500, n.sim=1500, n.thin=1)#
  ###Function summarymtar_simulation must be activated previously#
  summary_Bayes<-summarymtar_simulation(fit1_Bayes,Get.results = TRUE,Print.Results = FALSE)#
  nano <- forecasting(fit1_Bayes,subset(datos1,Fecha > fecha_final),row.names=Fecha)#
  forecasting_salida<-nano$summary#
  repl_slash[[replicas]]=list(forecasting=forecasting_salida,True_Values=subset(datos1,Fecha > fecha_final))#
  repl_slash_estimation[[replicas]]<-summary_Bayes#
  setTxtProgressBar(bar,replicas)#
  }#
#
end.time <- Sys.time()#
time.taken <- round(end.time - start.time,2)#
time.taken#
####Save Replications====#
save(repl_slash_estimation,repl_slash,extra,umbrales,Rg,file="replicas_slash_1000_reg.rds")
install.packages(mtarm)
install.packages("mtarm")
r
library(mtar)
